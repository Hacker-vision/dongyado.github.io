---
layout: post
title: 自己实现lru算法
date: 2016-04-13
categories:
- Algorithm
- funny
tags: [funny，Algorithm]
status: publish
type: post
published: true
author:
  login: slayer
  email: dongyado@gmail.com
  display_name: slayer
--
### LRU 的来源

LRU， Least Recently Used 近期最少使用算法， 常应用于缓存中的数据淘汰， 其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高“。

### 一般实现思路

仔细看下这个算法的定义： 近期最少使用算法，其实就是按照近期最少使用这个条件去淘汰相应的数据。

举个例子，内存的访问速度要远远大于硬盘，假如有一块内存只能存放100个数据，有个专门的程序否则管理这块内存的数据，流程大致如下：

客户端 -> 请求某个数据 -> 程序处理 -> 内存中有数据 -> 直接返回数据  
                               |-> 内存无数据 -> 读取磁盘 -> 存储到内存 -> 返回数据

这样，当不停的访问新的数据，内存迟早会满，因为内存访问速度远大于硬盘，所以应该把经常使用的数据放内存，而不常用的数据放磁盘。

所以就书要一个算法，在内存满的时候，淘汰那些不常用的数据，空出空间存储新的数据，恩，可以用LRU。

既然是淘汰最近最少使用的数据，姑且就可以理解为，当内存满了的那个时刻，内存中，哪些数据最后一次被访问的时间离现在最短，
不就表示哪些数据是冷数据，应该被移除。

假如每条数据有一个属性用来记录被访问时的时间，这样，每一条数据都有一个最后访问时间，当内存满的时候，只需把访问时间最前的数据的内存释放即可。

所以算法的核心，就是找出最远被访问的数据并删除,这里使用最简单的遍历方法：

    lasttime = current_time()
    lastKey = null;
    if list full:
        foreach each item of list:
            if item.lasttime < lasttime:
                lasttime = item.lasttime
                lastKey = item.key
         
         

然后把lastKey指向的那条数据删除，当然可以改进上面的算法，一次删除多条数据，提高操作效率。

这个算法是可行的，但是有一个很大的问题，慢！
试想一下，假如有一千万条数据，每次删除都需要找出访问时间最早的那些数据，这是很耗资源的操作，时间复杂度是O（N），跟数据量成正比，数据量越大，越慢。

# 优雅的实现思路